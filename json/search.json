[
    {
        "uri": "/content/admin/console-app/index",
        "title": "Using the console to test Policies",
        "content": "The TFSAggregator2.ConsoleApp.exe command line tool is extremely useful to test and validate\r\nyour policy files before applying to TFS.\r\n\r\n BEWARE Any changed workitem is written to TFS database! Use a test TFS instance.\r\n\r\n\r\nSyntax\r\n\r\n`\r\n TFSAggregator2.ConsoleApp.exe command [options]\r\n`\r\nThe only supported command is run.\r\n\r\nIf you launch the command without arguments, it will display an help screen. \r\n\r\n Options\r\nThe available options are:\r\n\r\n| Option br (short form) | Option br (long form) | Usage                                                                      |\r\n|------|------------------------------------|-------------------------------------------------------------------------------------|\r\n| -h | --help                           | Shows help message and exit                                                         |\r\n| -f | --policyFile=VALUE               | Policy file to test                                                                 |\r\n| -c | --teamProjectCollectionUrl=VALUE | TFS Team Project Collection Url, e.g. http://localhost:8080/tfs/DefaultCollection |\r\n| -p | --teamProjectName=VALUE          | TFS Team Project                                                                    |\r\n| -n | --id=VALUE[,VALUE...] br --workItemId=VALUE[,VALUE...] | List of Work Item Ids                                       |\r\n| -l | --logLevel=VALUE                 | Logging level (critical, error, warning, information, normal, verbose, diagnostic)  |\r\n\r\nThe log level specified on the command line takes precedence over the level written in the policy file. \r\n\r\n\r\nSample invocation\r\n\r\n`\r\nTFSAggregator2.ConsoleApp.exe run --policyFile=samples\\TFSAggregator2.ServerPlugin.policies --teamProjectCollectionUrl=http://localhost:8080/tfs/DefaultCollection --teamProjectName=TfsAggregatorTest1 --workItemId=42 --logLevel=diagnostic\r\n`\r\n\r\n Sample output\r\n\r\nThe output from the previous invocation should be similar to the following screenshot. \r\n\r\n\r\n\r\n\r\n\r\nDifferences from TFS Plugin\r\n\r\nHere are some major behavioral differences.\r\n\r\n All logging is redirected to the console.\r\n If a work item is changed by the rule, it will be processed again by the tool to emulate TFS behavior.\r\n The order of processing may be different from TFS.\r\n TFS may use different application tier servers to process rules.\r\n\r\nThe following diagrams may help understand the control flow.\r\n\r\n\r\nNormal flow using plugin\r\n\r\n\r\nDevelopment flow using Console Application",
        "tags": []
    },
    {
        "uri": "/content/admin/index",
        "title": "Administrator Guide",
        "content": "\r\nAdministrator Guide to TFS Aggregator\r\n\r\nThis Guide explains how install TFS Aggregator on premise and in the cloud for both the Web Hooks and Server Plugin flavors.",
        "tags": []
    },
    {
        "uri": "/content/admin/install-webhooks/index",
        "title": "Installing WebHooks",
        "content": "\r\nInstalling TFS Aggregator WebHooks is a six step process:\r\n\r\n Grant access to VSTS/TFS\r\n Deploy TfsAggregator WebHooks web application\r\n Configure TFS Aggregator\r\n Define the policy\r\n Setup logging (optional)\r\n Setup the Web Hooks in TFS/VSTS\r\n\r\n\r\n\r\nGrant access to VSTS/TFS\r\n\r\nThere are  three possible options to grant access. In most cases you will have to change the configuration later using the values collected in this step.\r\n\r\n 1. Using a Personal Access Token\r\n\r\na. Create a Personal Access Token \r\n Leave All scopes select; TFS Aggregator use the old Object Model (see Authentication issue using Personal Access Token when all options of \"Selected Scope\" are selected).\r\nb. Capture Personal Access Token's value and store it for later \r\n\r\n NOTE: this is per-account value you can use (User Profile/Security)\r\n\r\n2. [TFS only] Account permissions\r\ninstead of a PAT, you can give permission to the account running the Application Pool (see https://github.com/tfsaggregator/tfsaggregator/wiki/troubleshooting)\r\n\r\n 3. [TFS only] Explicit credentials \r\nor put username and password in clear text in the /AggregatorConfiguration/runtime/authentication node of the policy file\r\n\r\nIf you do not allow access expect a similar error\r\n\r\n\r\n\r\n\r\nDeploy TfsAggregator WebHooks web application\r\n\r\n 1. [TFS only] Install on IIS \r\n\r\nTo install TfsAggregator WebHooks web application you can use the Deploy-TfsAggregatorWebHooks.ps1 as a sample script\r\n use SSL to avoid exposing credentials\r\n the account running Aggregator application pool must have proper permissions on the target TFS or you set some credentials in the policy file\r\n\r\n2. Deploy to Azure\r\n\r\nUse the  button.\r\nThis is the simplest option for VSTS.\r\n\r\nIn the wizard specify the \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nPlease take note of the URL for the next steps.\r\n\r\nYou can check that the deploy worked, by opening a browser to the above URL appending /api/workitem\r\n \r\n\r\n\r\n\r\n\r\n Configure TFS Aggregator\r\n\r\nTo edit the deployed files, use Kudu console\r\n\r\n\r\n\r\nat the https://namechoseninpreviousstep.scm.azurewebsites.net URL. Navigate to site\\wwwroot folder via Debug console menu.\r\n\r\n\r\n\r\nAdd users to web.config file\r\n\r\nAdd at least one user in the Users section\r\n`\r\n  Users\r\n    add key=\"vsts\" value=\"P@ssw0rd!\" /\r\n  /Users\r\n`\r\n\r\n Configure the policy mapping\r\n\r\nDefine the policyFilePath in web.config; the default value is the static path of the sample policy.\r\n\r\n\r\n\r\nInstead of a static path you can use a variable value from the incoming request e.g. add key=\"policyFilePath\" value=\"~/App_Data/{CollectionId}.policies\" /.\r\nThe possible variables for policyFilePath, extracted from the incoming request data are:\r\n {EventType} could be workitem.created workitem.updated workitem.restored or workitem.deleted\r\n {AccountId} Guid of VSTS Account (TFS 2017 or later)\r\n {CollectionId} Guid of collection\r\n {TeamProject} name of the Team Project\r\n {TfsCollectionUri} URL of the collection\r\n\r\n\r\n\r\nDefine the policy\r\n\r\nNavigate to the App_Data folder to edit the policy files\r\n\r\n\r\n\r\n The default HelloWorld policy works for any kind of work items.\r\n\r\n Specify Authentication in the policy\r\nThe runtime/authentication element accept two new options\r\n\r\n Explicit credentials\r\n    authentication username=\"DOMAIN\\user\" password=\"***\" /\r\n    not much secure, but handy for testing and some edge scenario\r\n Personal Access Token (obtained on step 1)\r\n    authentication personalToken=\"***\" /\r\n\r\nIn the policies you may have to set the credentials chosen in the first step, e.g. the PAT. \r\n\r\n\r\n\r\n\r\n\r\nSetup logging (optional)\r\n\r\nThis step is not mandatory, but recommended in the initial phase.\r\n\r\nIn the Azure Portal navigate to App Services and select the App Service hosting TFS Aggregator. Scroll down to Diagnostic logs and turn on Application Logging.\r\n\r\n\r\n\r\nSelect the Verbosity level and save.\r\n\r\n You can store the logs in Azure storage for auditing.\r\n\r\nIn the Kudu console navigate to the LogFiles\\Application folder to find the log files produced by TFS Aggregator.\r\n\r\n\r\n\r\nBy opening the file you see a snapshot of log file's content.\r\n\r\n\r\n\r\n\r\n\r\n Setup the Web Hooks in TFS/VSTS\r\n\r\nThis is the last step: setup the caller, i.e. configure VSTS/TFS to invoke TFS Aggregator (see also Web Hooks).\r\n\r\nUsing Powershell\r\n\r\nIn the samples folder you can find the Create-Subscriptions.ps1 Powershell script to quickly setup the subscription.\r\nIt requires six arguments and creates the subcription for create, update and restore events.\r\n\r\n| Argument            | Description                                             | Sample value |\r\n|---------------------|---------------------------------------------------------|-----------------------------------------------------------|\r\n| tfsURL              | TFS/VSTS base URL                                       | https://me.visualstudio.com/                            |\r\n| ProjectName         | TFS/VSTS project name                                   | My Project                                              |\r\n| PersonalAccessToken | Personal Access Token generated in step 1               | jocxco3i7twydcif25bh7yysbodwnq4ppuannhro4yryfcbab4na    |\r\n| aggregatorURL       | URL of TFS Aggregator WebHooks API                      | https://mytfsaggregator.azurewebsites.net/api/workitem/ |\r\n| aggregatorUsername  | Username listed in TFS Aggregator WebHooks web.config | vsts                                                    |\r\n| aggregatorPassword  | Password for the above                                  | P@ssw0rd!                                               |\r\n\r\n The workitem.deleted fails with error TF26198: The work item does not exist, or you do not have permission to access it.\r\n This is an issue with VSTS/TFS that we cannot solve.\r\n\r\n Manual configuration\r\n\r\n NOTE: this is a per-project configuration (Project/Admin).\r\n\r\n\r\n\r\n\r\n\r\nSelect Web Hooks\r\n\r\n\r\nSelect the triggering event\r\n\r\n\r\n You may have to repeat this step for all four event:\r\n * New/created\r\n * Change/updated\r\n * Delete\r\n * Restore\r\n\r\nInsert the URL, e.g. https://namechosenindeploystep.azurewebsites.net/api/workitem and one user listed in TFS Aggregator web.config file.\r\n \r\n\r\n\r\n NOTE the Test button above may send a well-formed document or not, so to test if everything works you really must create/modify some work item.\r\n\r\nThis is the result with a single hooked event.\r\n\r\n\r\nAnd after all four events are defined.\r\n\r\n\r\n\r\n\r\nFinal testing\r\n\r\nAt this point the configuration is complete and you can test, e.g. creating a new work item.\r\n\r\n\r\n\r\nYou see in the Service Hooks page\r\n\r\n\r\n\r\nthe success or failure.\r\nRemember that you can see the TFS Aggregator log to help troubleshooting.\r\n",
        "tags": []
    },
    {
        "uri": "/content/admin/install/index",
        "title": "Installing the Plugin",
        "content": "\r\n This information does not apply to the WebHooks version.\r\n\r\nPre-requisites\r\n TFS ###\r\n\r\nThe TFS Aggregator works with the following versions of TFS:\r\n\r\n TFS 2013 update 2,3,4,5\r\n TFS 2015 RTM\r\n TFS 2015 update 1,2,3\r\n TFS 2017 RTM\r\n\r\nThe installer will detect the correct TFS version and will install the appropriate binary. If you're upgrading, please uninstall your current TFS Aggregator version, upgrade TFS, then run the installer to automatically install the matching version.\r\n\r\nWindows Event log\r\n\r\nThe TFS Aggregator plugins writes to Windows Event log critical errors; the TFSAggregator Source must be defined in the Application log. The MSI takes care of this.\r\n\r\n Account permissions\r\n\r\nThe TFS service account must have permissions to change your work items (on behalf of others if you have enabled impersonation).\r\n\r\n\r\n\r\nAutomated Setup using Windows Installer\r\n\r\nDownload TFSAggregator MSI file from the latest Release.\r\n\r\nUnblock the downloaded file.\r\n\r\n\r\n\r\nLaunch the installer and accept the license\r\n\r\n\r\n\r\nThe MSI packages all three Aggregator flavors, one for each supported TFS version.\r\nThe installer detects the TFS version installed and deploy the correct assemblies.\r\n\r\n The installer detects automatically the TFS version: it fails if TFS is not present.\r\n\r\n\r\n\r\nIt will install under %ProgramFiles%, typically C:\\Program Files\\TFS Aggregator, three folders: bin, docs and samples.\r\n\r\n\r\nFurthermore it installs the plugin in the proper directory &mdash; for TFS 2015 can be C:\\Program Files\\Microsoft Team Foundation Server 14.0\\Application Tier\\Web Services\\bin\\Plugins &mdash; the plugin assemblies and the default no-op Policy file samples\\TFSAggregator2.ServerPlugin.policies.\r\n An existing Policy file is not overwritten.\r\n\r\n\r\n Sample Install scripts\r\n\r\nIn the samples folder you will find two Powershell scripts to install or remove Aggregator in case the TFS Administrator does not want (or can) use the MSI file. \r\nThe scripts require an elevated Powershell prompt.\r\n\r\n\r\n\r\nConfigure\r\n\r\nTo configure Aggregator you must add new rules in the policy file.\r\n \r\n Edit a copy of the sample TFSAggregator2.ServerPlugin.policies file.\r\n Test your new policy using TFSAggregator2.ConsoleApp.exe command line tool\r\n Copy the new file to the plugin folder; usually at this path for TFS 2015:\r\n    C:\\Program Files\\Microsoft Team Foundation Server 14.0\\Application Tier\\Web Services\\bin\\Plugins \r\n Verify that your new policy works; see TFS Aggregator Troubleshooting in case of problems.\r\n\r\nSee Console Application for more information on using the command line tool.\r\n\r\n Upgrade TFS to a new version\r\nDue to the fact that there have been breaking changes between TFS Server Object Model versions, there may be a need to fix the TFS aggregator after an upgrade.\r\n\r\nWhen upgrading from/to specific versions, you need to uninstall TFS aggregator before upgrading the Application Tier server re-install it afterwards.\r\n\r\nTFS 2013 update 5\r\n to TFS 2015 RTM\r\n to TFS 2015 update 3\r\nTFS 2015 RTM\r\n to TFS 2015 update 3\r\n to TFS 2017 RTM\r\nTFS 2015 Update 3\r\n to TFS 2017\r\n\r\nAn uninstall+reinstall is required, repairing may not work. TFS will detect the incompatibility and will not load the plugin if the version mismatches.\r\n\r\nManual Setup\r\n\r\n\r\n Manual install\r\n\r\n Download and extract the binaries from the latest release\r\n Create TFSAggregator2.ServerPlugin.policies using one of the provides examples to build your actual policy.\r\n    You will find the complete syntax and examples following the links.\r\n Test your policy using  TFSAggregator2.ConsoleApp.exe command line tool, see TFS Aggregator Troubleshooting.\r\n Register the EventLog source for TFS Aggregator, using an elevated Powershell prompt, by running\r\n    `\r\nNew-EventLog -LogName \"Application\" -Source \"TFSAggregator\"\r\n    `\r\n Copy TFSAggregator2.ServerPlugin.dll, TFSAggregator2.Core.dll and TFSAggregator2.ServerPlugin.policies to the plugin location on the Application Tier of your TFS Servers:\r\n     The plugin folder is usually at this path for TFS 2015: C:\\Program Files\\Microsoft Team Foundation Server 14.0\\Application Tier\\Web Services\\bin\\Plugins;\r\n     You must copy the exact same files on all TFS Application Tier servers.\r\n\r\nTFS detects automatically that a file was copied in and will load it in.\r\n\r\nYou can verify if assembly version matches TFS version using this Powershell code\r\n\r\n`\r\n$pathToAssemblyFile = \"C:\\Program Files\\Microsoft Team Foundation Server 14.0\\Application Tier\\Web Services\\bin\\Plugins\\TFSAggregator2.ServerPlugin.dll\"\r\n[System.Reflection.Assembly]::LoadFile($pathToAssemblyFile).GetCustomAttributesData() | ?{ $_.AttributeType -eq [System.Reflection.AssemblyConfigurationAttribute] } | select ConstructorArguments\r\n`\r\n\r\n\r\nManual Uninstall\r\n\r\nRemove the TFSAggregator2.* files from the plugin location on the Application Tier of your TFS Servers\r\n\r\nThe plugin folder is usually at this path:\r\n\r\n TFS 2015: C:\\Program Files\\Microsoft Team Foundation Server 14.0\\Application Tier\\Web Services\\bin\\Plugins\r\n TFS 2013: C:\\Program Files\\Microsoft Team Foundation Server 12.0\\Application Tier\\Web Services\\bin\\Plugins\r\n",
        "tags": []
    },
    {
        "uri": "/content/admin/security/index",
        "title": "Security",
        "content": "\r\nWe strove to limit the API exposed to Rules and the chance of unwanted access.\r\n\r\nIt is up to the TFS Administrator validate and deploy the policy file on production TFS.\r\n\r\nTest the policy file on a TFS staging environment with a single Application Tier server. If you have more than one enabled, TFS can be turned temporarily off on a server using TFSServiceControl quiesce command.\r\n\r\nUse the Rate Limit feature to reduce the chance of infinite loops.",
        "tags": []
    },
    {
        "uri": "/content/admin/troubleshooting/index",
        "title": "Troubleshooting",
        "content": "So you setup TFS Aggregator and it just sits there.... doing nothing...\r\n\r\nWell, this is a check list of things to double check.\r\n\r\n\r\nChecklist\r\n\r\n You are using it on a TFS 2013 (update 2 or later) or 2015 (RTM or later) server (and you have the right version for the right server).\r\n You have updated a work item that triggers a rule. (The TFS Aggregation only works once a work item that has aggregation rules on it is updated. This may change in a future version.)\r\n If the rule navigates between work items, work items have a proper Link (e.g. Parent-Child).\r\n You copied the DLLs and the Policies file to the plugins location on all TFS Application Tier Servers (Usually at: Drive:\\Program Files\\Microsoft Team Foundation Server {version}\\Application Tier\\Web Services\\bin\\Plugins)\r\n You have valid names for source and destination fields in TFSAggregator2.ServerPlugin.policies.\r\n When you saved the file you saved it as UTF-8 encoding (in Notepad++ it is called “utf-8 without BOM”) (This should not be an issue, but it does not hurt to check).\r\n You have given permission to the user running the plugin, e.g. add the \"TFS Service Account\" to the Project Collection Administrators TFS Group.\r\n  You may have to do this from the commandline using tfssecurity /collection:http://server:8080/tfs/DefaultCollection /g+ \"Project Collection administrators\" \"LOCAL SERVICE\" if your service account is either LocalService, NetworkService or any other Windows Well-known identity, since they are no longer shown in the permission UI.\r\n When using the Impersonation option, make sure the user executing the plugin (generally the TFS Service account) has the \"Make requests on behalf of others\" permission at the server level\r\n If you upgraded your TFS from 2013.x to 2015.* or to 2017 and from 2015rtm to 2015.1 and did not uninstall the TFS Aggregator before doing this TFS upgrade the aggregator does not work. Remove the TFS Aggregator from the TFS 2013 Program Files folder or run the uninstall of the TFS Aggegrator (backup your policies!). Then re-install the TFS Aggegrator setup or install manually for TFS 2015 as described here. Every TFS version has its \"own\" assembly for the aggregator so it is important to use the right version against the right TFS. Check\r\n\r\n\r\nAlso if you are having issues we recommend debugging your Policies file using TFSAggregator2.ConsoleApp.exe and trying that out.\r\n\r\n\r\n Use Console Application\r\n\r\nThe TFSAggregator2.ConsoleApp.exe command line tool is extremely useful to test and validate your policy files before applying to TFS.\r\n\r\nSample invocation\r\n\r\n`\r\nTFSAggregator2.ConsoleApp.exe run --logLevel=diagnostic --policyFile=samples\\TFSAggregator2.ServerPlugin.policies --teamProjectCollectionUrl=http://localhost:8080/tfs/DefaultCollection --teamProjectName=TfsAggregatorTest1 --workItemId=42\r\n`\r\n\r\nSee Console Application for more information on using the command line tool.\r\n\r\n\r\nEnable Debug Logging\r\n\r\nYou can also enable Logging. There are two parts to enable logging.\r\n\r\nThe first is that you have to set a level attribute to the logging element in your TFSAggregator2.ServerPlugin.policies file.\r\nUse a value like Verbose or Diagnostic.\r\n\r\n`\r\n?xml version=\"1.0\" encoding=\"utf-8\"?\r\nAggregatorConfiguration\r\n    runtime\r\n        logging level=\"Diagnostic\"/\r\n    /runtime\r\n`\r\n\r\nThen you need to download DebugView from Microsoft's SysInternals site.\r\n\r\nDebugView is a Trace Listener and will capture the trace messages from TFSAggregator.\r\n\r\n\r\n You have to run DebugView on _all_ TFS Application Tier machines.\r\n\r\nWe would recommend adding the TFSAggregator filter to DebugView so that you only see the TFSAggregator traces.\r\n\r\n\r\n\r\nMake sure to enable the Capture Global Win32 option.\r\nDownload DebugView at http://technet.microsoft.com/en-us/sysinternals/bb896647.\r\n\r\nNote that you can use the logger object in your rules to trace execution and  values.\r\n\r\n\r\n Production Logging (2.1)\r\n\r\nTFS Aggregator log messages go to:\r\nDebug output (appers in the Output window of a debugger)\r\nApplication EventLog (TFS Aggregator source) when message level is Warning or Critical\r\nTrace listeners\r\n\r\nUser messages -- i.e. logger.Log calls in Rules -- use a specific Trace source: TfsAggregator.User.\r\n\r\nNow, you can send traces to a file by adding to TFS web.config a system.diagnostics section similar to the this:\r\n\r\n`\r\nsystem.diagnostics\r\n  sources\r\n    source name=\"TfsAggregator.ServerPlugin\" switchValue=\"All\"\r\n      listeners\r\n        remove name=\"Default\" /\r\n        add name=\"filelog\" /\r\n      /listeners\r\n    /source\r\n    source name=\"TfsAggregator.User\" switchValue=\"All\"\r\n      listeners\r\n        remove name=\"Default\" /\r\n        add name=\"filelog\" /\r\n      /listeners\r\n    /source\r\n  /sources\r\n  sharedListeners\r\n    <add name=\"filelog\"\r\n         type=\"Microsoft.VisualBasic.Logging.FileLogTraceListener, \r\n                   Microsoft.VisualBasic, Version=10.0.0.0, \r\n                   Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\"\r\n         BaseFileName=\"TfsAggregator.log\"\r\n         DiskSpaceExhaustedBehavior=\"ThrowException\"\r\n         Location=\"Custom\"\r\n         CustomLocation = \"C:\\Temp\"\r\n         MaxFileSize=\"81920000\"\r\n         LogFileCreationSchedule=\"Daily\"/\r\n  /sharedListeners\r\n  trace autoflush=\"true\"/\r\n/system.diagnostics\r\n`\r\n\r\nTFS web.config is located in C:\\Program Files\\Microsoft Team Foundation Server 14.0\\Application Tier\\Web Services\\web.config or similar.\r\n\r\n\r\nSupport\r\n\r\nIf you check all the above items and it still does not work , create a new Issue on GitHub. Please add any useful information like:\r\n\r\n Aggregator version\r\n TFS version\r\n Content of your TFSAggregator2.ServerPlugin.policies file (e.g. save it on https://gist.github.com/ and copy the link in the Issue)\r\n Definition of your work item types (use witadmin exportwitd)\r\n\r\nIf you built the assemblies yourselves, they have a fixed 2.0.0.0 version. Please report, the source code version (Tag or commit SHA) used to build your binaries.  \r\n\r\n Remove any sensitive information before posting!\r\n  \r\nConsider that this is a voluntary work and we have families and daily jobs, which means: no guarantee of fast response.\r\nTimezone differences may also impact on response times.",
        "tags": []
    },
    {
        "uri": "/content/CHANGELOG",
        "content": "History of Changes\r\n\r\n What’s new in v2.3 (beta)\r\n\r\n Support for VSTS & TFS 2015 / 2017 Web Hooks via Web Service\r\n Additional authentication modes\r\n Rule filter on change event (New,Change,Delete,Restore)\r\n Deploy to Azure button for an easy deployment\r\n\r\nWhat's new in v2.2\r\n Support for TFS 2017\r\n Macro snippets and Functions for Rules and make code more modular\r\n Ability to specify server URL\r\n Support for multiple workitem Ids in Console application (issue 178)\r\n Ability to Send email from Rules\r\n Migrated CI build from AppVeyor to VSTS\r\n Use of GitVersion to manage Semantic Versioning\r\n\r\nWhat's new in v2.1.1\r\n Fixes important bug causing very high CPU usage (see 160).\r\n\r\nWhat's new in v2.1\r\n\r\n Support for TFS 2015.2, TFS 2015.2.1 and TFS 2015.3\r\n Extended logging in debug version\r\n Ability to override base Uri of the aggregator\r\n Improvements in the setup\r\n Adds PreviousRevision/NextRevision properties to Work Items to navigate history\r\n Adds Uri field to Work Items\r\n Removed policyscope on Workitem template GUID and revision (didn't work anyway)\r\n\r\n What's new in v2\r\n\r\n A 'real' Scripting language (C#, VB, Powershell)\r\n Scoping allows select which rules apply to which Team Project\r\n Enhanced filtering to trigger rules when conditions are met\r\n Console application to quickly test new rules\r\n Richer logging\r\n Test harness and modularity to ease adding new features\r\n Create new Work Items and Links using rules\r\n and more...\r\n\r\n",
        "tags": []
    },
    {
        "uri": "/content/contrib/continuous-integration",
        "title": "Continuous Integration",
        "content": "We moved to VSTS for Continuous Integration.\r\n\r\nCI Builds for:\r\n develop\r\n feature/*\r\ndo not produce artifacts, i.e. the MSI file.\r\n\r\nBuilds that actually generate artifacts:\r\n master\r\n release/*\r\n hotfix/*\r\n\r\nThe Reference folder is filled with files from $/TfsAggregator2/References as the assemblies are not redistributable.\r\nAs explained in Local build these assemblies are tied to the target TFS version.\r\n\r\nThe script build Debug and Release configuration of TFS-Aggregator-2.sln and run tests.\r\n\r\nIf the tests are green, it produces the per-configuration MSIs launching the build-installer.proj.\r\n\r\nAsking access\r\n\r\nVSTS does not currently offers public projects, so if you need access to the CI build, ask the team for an invite.\r\n",
        "tags": []
    },
    {
        "uri": "/content/contrib/debugging",
        "title": "Debugging",
        "content": "For the best development experience, use a TFS 2013 or 2015 Virtual Machine with Visual Studio 2015 installed and work directly on the machine.\r\n\r\n Do not _ever_ debug on a production server!\r\n\r\nYou can then set the output folder for the project to\r\nC:\\Program Files\\Microsoft Team Foundation Server 12.0\\Application Tier\\Web Services\\bin\\Plugins\\\r\nor use the deploy.cmd file in Aggregator.ServerPlugin project to refresh Aggregator's assembly on a target test system. Here is a sample\r\n\r\n`\r\n@echo off\r\nset CONFIGURATION=%1\r\nset TARGETDIR=%2\r\nset PLUGIN_FOLDER=C:\\Program Files\\Microsoft Team Foundation Server 14.0\\Application Tier\\Web Services\\bin\\Plugins\r\n\r\necho Deploy '%CONFIGURATION%' from '%TARGETDIR%' to '%PLUGIN_FOLDER%'\r\n\r\ncopy /Y \"%TARGETDIR%\\TFSAggregator2.Core.dll\" \"%PLUGIN_FOLDER%\"\r\ncopy /Y \"%TARGETDIR%\\TFSAggregator2.Core.pdb\" \"%PLUGIN_FOLDER%\"\r\ncopy /Y \"%TARGETDIR%\\TFSAggregator2.ServerPlugin.dll\" \"%PLUGIN_FOLDER%\"\r\ncopy /Y \"%TARGETDIR%\\TFSAggregator2.ServerPlugin.pdb\" \"%PLUGIN_FOLDER%\"\r\n\r\nIF NOT EXIST \"%PLUGIN_FOLDER%\\TFSAggregator2.ServerPlugin.policies\" (\r\n    copy \"samples\\TFSAggregator2.ServerPlugin.policies\" \"%PLUGIN_FOLDER%\"\r\n)\r\n\r\necho Deploy complete.\r\n`\r\n\r\nDo not commit changes to this file!\r\n\r\nTo debug attach to the w3wp.exe on the server and set breakpoints as you would normally.\r\n\r\n Note. Use 12.0 for TFS 2013, 14.0 for TFS 2015 and 15.0 for TFS 2017.\r\n\r\n\r\nRemote Debugging\r\n\r\nTFS is not required to successfully build and debug Aggregator. Infact we successfully used Remote Debugging.\r\n\r\nSee Local build for additional details.\r\n",
        "tags": []
    },
    {
        "uri": "/content/contrib/developer-intro",
        "title": "Introduction to Contributors",
        "content": "So, you want to build yourself the binaries or want to fix a bug.\r\n\r\nTo enhance or fix bugs, please read Source code page to introduce yourself to the code. In Local build, we describe the build process: a mandatory read.\r\nUseful tips are contained in Debugging and Troubleshooting pages.\r\n\r\n\r\nTFS Breaking changes\r\n\r\nTFS Server API changed frequently in the past: TFS Aggregator contains specific checks for the TFS version.\r\nThese check can be:\r\nsource code conditional compile\r\nWiX sources\r\nMSBuild project files\r\nSo, caveat emptor: TFS versions are scattered all-over the places.\r\n\r\n\r\n Compile\r\n\r\nNote that to rebuild, edit or debug the code you must use Visual Studio 2015, Community or Professional Edition at a minimum (see Local build for details).\r\nTFS is not required locally: you can use Remote Debugging. \r\n\r\nThe CI build page explains some important things of our CI build infrastructure in VSTS.\r\n\r\n\r\nBranches\r\n\r\n|  Branch   | Artifacts | Purpose |\r\n|-----------|-----------|---------------|\r\n| master    | Yes | Released code, versions are tagged |\r\n| hotfix/*  | Yes | Fast release cycle for bug fixes, branches from tag, merged to master after Issuer confirms fix is working |\r\n| release/* | Yes | Release candidates, branch named after soon-to-be-relased version, tags mark interim releases |\r\n| develop   | No  | Integration branch for developers |\r\n| feature/* | No  | New feature, idea |\r\n\r\n\r\n Wiki\r\n\r\nWiki master branch content must match the latest release. To prepare documentation for a future release, use a branch as in the code repository.\r\n\r\n\r\nRelease process\r\n\r\n collect solved issues\r\n prepare Markdown release notes\r\n update wiki release/v branch\r\n tag repo\r\n merge release/v# branch to master (use PR when possible)\r\n create GitHub Release pasting release notes\r\n merge wiki release/v# branch to master and delete it\r\n download binaries and upload to Release\r\n merge master branch to develop\r\n increment v# in develop branch and push\r\n update Visual Studio Gallery pasting release notes\r\n spread the news: Twitter, Blog\r\n wait for bugs to arrive",
        "tags": []
    },
    {
        "uri": "/content/contrib/index",
        "title": "Contributing",
        "content": "\r\nContributors' Guide\r\n\r\nContributors are welcome!\r\n\r\nEven if you are not a developer, you can help the project by testing new versions or reviewing the documentation.\r\n\r\nIn this guide you can discover TFS Aggregator internal structure and the teams' rules.",
        "tags": []
    },
    {
        "uri": "/content/contrib/local-build",
        "title": "Local Build",
        "content": "Building the Solution\r\n\r\nTo rebuild, edit or debug the code you must use Visual Studio 2015, Community or Professional Edition at a minimum.\r\nIn addition you must install the following extensions from Visual Studio Gallery:\r\nWiX 3.10\r\nxUnit.net 1.0\r\n\r\nTFS is not required to build nor debugging (for this latter you can use Remote Debugging).\r\n\r\n\r\n References\r\n\r\nBuilding requires a number of TFS assemblies that cannot be redistributed. You can find the complete list in these files \r\n\r\n TFS 2013 update 2 or newer: References/2013/PLACEHOLDER.txt\r\n TFS 2015: References/2015/PLACEHOLDER.txt\r\n TFS 2015 Update 1: References/2015.1/PLACEHOLDER.txt\r\n TFS 2015 Update 2: References/2015.2/PLACEHOLDER.txt\r\n TFS 2017: References/2017/PLACEHOLDER.txt\r\n\r\nif you have TFS installed on your development machine, the assemblies for that version will be loaded automatically from the installation folder.\r\n\r\n\r\nSolution Configurations\r\n\r\nThe Build Configuration selected, like Debug-2013 or Release-2015, determines the target TFS version, that is the referenced assemblies.\r\n\r\nSadly, similar to the release of TFS 2013 update 2 when there were breaking changes, TFS 2015 Update 1 introduces a breaking change in the API, so you can find some conditionally compiled code based on the symbols TFS2013, TFS2015 or TFS2015u1.\r\n\r\n\r\n Version numbers\r\n\r\nAssemblies produced locally always have the 2.2.0.0 version, at least until we further enhance the build scripts.\r\n\r\n\r\n\r\n\r\nProduce the MSI Windows Installer\r\n\r\nThe build-installer.proj MSBuild script takes care of generating the Windows Installer MSI file.\r\n\r\nThe MSI packages all three Aggregator flavors, one for each supported TFS version.\r\nThe installer detects the TFS version installed and deploy the correct assemblies.\r\n\r\nThe MSBuild script builds three times the TFS-Aggregator-2.sln solution, one for each supported TFS version.\r\nThen the files are copied in a simple layout in the _collect folder. Some WiX source is generated and finally the Setup.Aggregator\\Setup.Aggregator.wixproj is launched to produce the MSI package.\r\n\r\n Caveat: TFS versions values are all-over the places, e.g.\r\n - source code conditional compile\r\n - WiX sources\r\n - MSBuild project files\r\n\r\n\r\nTo generate the MSI, in an MSBuild Command Prompt (VS2015) or a Developer Command Prompt (VS2013) run\r\n\r\n`\r\nmsbuild build-installer.proj /p:Configuration=Release\r\n`\r\n\r\nThe Configuration property is mandatory; allowed values are Debug and Release.\r\n\r\n \r\nThree MSBuild properties BuildSolution, CollectFiles, BuildMSI, whose meaning is self-explanatory, can be used to skip some process' steps.\r\n\r\n`\r\nmsbuild build-installer.proj /p:Configuration=Release /p:BuildSolution=False /p:CollectFiles=False /p:BuildMSI=True\r\n`\r\n\r\nMSI file is available in Setup.Aggregator\\bin\\$(Configuration) as TFSAggregator-0.2.2-alpha+local-$(Configuration).msi. Notice the zero version number to highlight that is has been produced locally.\r\n\r\n Caveat: avoid modifying anything in this area unless you are fluent in MSBuild, WiX and Windows Installer technologies.\r\n",
        "tags": []
    },
    {
        "uri": "/content/contrib/source-code",
        "title": "Source Code",
        "content": "This page explains the design and internal organization of TFS Aggregator v2's code.\r\nIf you want to rebuild, customize, submit changes this is the place to start.\r\n\r\n\r\n\r\nMajor Components\r\n\r\nThe Aggregator.Core assembly contains the logic to process a Work Item and run the aggregate scripts.\r\nIt is normally used by Aggregator.ServerPlugin which intercept the TFS server side events and forward them to Aggregator.Core.\r\nAggregator.ConsoleApp is a simple console app that helps users in developing and testing policies without installing the server plugin.\r\n\r\n\r\n\r\n Source Code Organization\r\n\r\nThe project is available on GitHub.\r\nWe use a simple master/develop/pull-request branching scheme.\r\nAll the source is available in the TFS-Aggregator-2.sln Visual Studio 2015 solution.\r\nTo produce the MSI, see [Local build/contrib/local-build).\r\n\r\n\r\nPolicy data\r\n\r\nAggregator parses the Policy file at start. The logic is contained in Aggregator.Core/Configuration;\r\nwhose entry point is the Aggregator.Core.Configuration.TFSAggregatorSettings class.\r\nThat class is also the root of the configuration data model: Aggregator code gets a reference to a TFSAggregatorSettings instance to configure.\r\n\r\nYou can populate this class from a different source like a database.\r\n\r\n\r\n Object Model\r\n\r\nAggregator's Object Model solves some objectives:\r\n simplifying the scripts\r\n decouple from TFS Object Model\r\n Ease mocking i.e. testing\r\n\r\nYou find the OM interfaces in Aggregator.Core/Interfaces and the implementation for the TFS OM in Aggregator.Core/Facade.\r\n\r\nSee Scripting for an introduction.\r\n\r\n\r\nScripting\r\n\r\nAggregator.Core/Script contains the build and execute logic for all scripting engines.\r\nFor C and VB, the script code is compiled once and the produced assembly is reused until the plug-in restarts.\r\nThe DotNetScriptEngine base class contains all the logic while CSharpScriptEngine and VBNetScriptEngine define how to sew the script's code snippets toghether.\r\nPowershell support is experimental.\r\n\r\n\r\nLogging\r\n\r\nThe Core is decoupled from the logging sub-system: interesting events are pushed via the Aggregator.Core.ILogEvents interface that each client must implement.\r\nThis way the same event generate a message in the log file or on the console. Important messages create EventLog messages on the server but not on the console application.\r\n\r\nTo add a message you have to:\r\n add a method to ILogEvents interface\r\n implement the method in TextLogComposer class\r\n\r\n Note that the calling site is invoking a method passing typed parameters.\r\n TextLogComposer implementation set the message level and compose the text properly formatting the parameters.\r\n\r\n\r\n What's next\r\n\r\nPlease read Local build, Debugging and Troubleshooting to get a complete picture.",
        "tags": []
    },
    {
        "uri": "/content/intro/how-it-works/index",
        "title": "How it Works",
        "content": "\r\nWeb Hooks\r\n\r\nTODO\r\n\r\n Server Plugin\r\n\r\nThe following diagram may help understand the control flow.\r\n\r\n\r\n\r\n A user changes some work item's data using Visual Studio or TFS Web Interface, then presses the Save button (or hits Ctrl-S);\r\n TFS validates the edit and saves the changes to the database;\r\n TFS notifies the Aggregator plugin of the ID of the changed work item\r\n Aggregator see which Rules apply and execute them, which may cause the loading and saving of additional work items.\r\n\r\n Note that step 4 may trigger Aggregator again on the just saved work items.\r\n\r\nKeep also in mind that scripts and applications can change work items without user intervention, like Team Foundation Server Integration Tools. Make sure that TFS Aggregator kicks in only when intended.\r\n\r\n\r\nConfiguration changes\r\n\r\nAggregator loads and parses the Rules from TFSAggregator2.ServerPlugin.policies file at first run. The result is cached in memory and the cache invalidates if the file changes.",
        "tags": []
    },
    {
        "uri": "/content/intro/index",
        "title": "Introduction",
        "content": "\r\nTFS Aggregator is a extension for Team Foundation Server (TFS) and Visual Studio Team Services (VSTS)\r\nthat enables running custom script when Work Items change,\r\nallowing dynamic calculation of field values in TFS and more.\r\n(For example: Dev work + Test Work = Total Work).\r\n\r\nYou can use the Server Plugin, for TFS 2013 update 2 up to TFS 2017 RTM, or the Web Hooks version, for VSTS or TFS 2015 and later.\r\n\r\n The Web Hooks version is still in beta.\r\n\r\n TFS Server API changed frequently in the past: the Server Plugin contains specific checks for the TFS version.\r\n TFS Aggregator Server Plugin binaries will work only with a specific TFS version.\r\n\r\nSee the Changelog for an history of releases.\r\n\r\nExample Uses\r\n\r\n Update the state of a Bug, PBI (or any parent) to \"In Progress\" when a child gets moved to \"In Progress\"\r\n Update the state of a Bug, PBI (or any parent) to \"Done\" when all children get moved to \"Done\" or \"Removed\"\r\n Update the \"Work Remaining\" on a Bug, PBI, etc with the sum of all the Task's \"Work Remaining\".\r\n Update the \"Work Remaining\" on a Sprint with the sum of all the \"Work Remaining\" of its grandchildren (i.e. tasks of the PBIs and Bugs in the Sprint).\r\n Sum up totals on a single work item (i.e. Dev Estimate + Test Estimate = Total Estimate)\r\n Create new work items\r\n Create new work item links\r\n\r\n Setup & install\r\n\r\nThe easiest way to deploy the Web Hooks version is to use the Deploy to Azure button on the repository page.\r\n\r\nThe latest Install package contains A fully automated setup for the Server Plugin.\r\n\r\nA manual installation after building from source follows the following process:\r\n\r\n Download and extract the binaries from the latest release\r\n Create a file named TFSAggregator2.ServerPlugin.policies (or rename one of the existing samples to get started) and change the example settings to your actual settings. Syntax Example. \r\n Test your policy using the command line tool.\r\n Copy TFSAggregator2.ServerPlugin.dll, TFSAggregator2.Core.dll and TFSAggregator2.ServerPlugin.policies to the plugin location on the Application Tier of your TFS Servers\r\n\r\nThat is all. TFS will detect that a file was copied in and will load it in.\r\n\r\nWe ship with an MSI installer which will automatically detect your TFS server folder.\r\n\r\n WARNING When upgrading your TFS server you should uninstall the TFS Aggregator Server Plugin prior to the upgrade and then run the new installer when your server upgrade has completed.\r\n\r\n\r\nBetas\r\nYou can pick development binaries directly from VSTS, asking access to the team, see CI build for details.\r\n\r\n\r\n Troubleshooting\r\nIs it not working? Here is the troubleshooting and how to get help page: TFS Aggregator Troubleshooting\r\n\r\n\r\nMigrating from v2.x\r\nNo action required.\r\n\r\n\r\n Migrating from v1\r\nIf you used TFS Aggregator in the past, here are the instructions on switching from older versions.\r\n\r\nIf you're looking for the latest version of V1 (including a large number of fixes and security updates), you can still find it here. \r\n\r\nNote: we won't provide any further support on this old version. But if you have a large investment in the old-style rules, it may provide you a better, stabler version until you're ready to move to V2. \r\n\r\nNote: You can run both V1 and V2 side-by-side on the same TFS system, you will have to be extra careful not to create infinite loops though.\r\n\r\nBuild and customize\r\nWe used Visual Studio Community Edition 2015 Update 2 to develop this version.\r\nCompiling requires a number of TFS assemblies that cannot be redistributed. \r\n\r\nYou can find the complete list in these files:\r\n\r\n 2013 Update 2 and later: References/2013/PLACEHOLDER.txt\r\n 2015 RTM: References/2015/PLACEHOLDER.txt\r\n 2015 Update 1: References/2015.1/PLACEHOLDER.txt\r\n 2015 Update 2 or 3: References/2015.2/PLACEHOLDER.txt\r\n 2017 RTM: References/2017/PLACEHOLDER.txt\r\n\r\nIf you have TFS installed on your development machine, the assemblies for that version will be loaded automatically from the installation folder.\r\n\r\nMore information on customizing and the internal design of TFS Aggregator is here.",
        "tags": []
    },
    {
        "uri": "/content/intro/slack-coc",
        "title": "Code of Conduct",
        "content": "\r\nTFS Aggregator Slack - Code of Conduct\r\n\r\nTODO",
        "tags": []
    },
    {
        "uri": "/content/using/examples/auto-create-children",
        "title": "Auto-Create Children",
        "content": "\r\nExample: Auto-Create Children\r\nProcess template: Any\r\n\r\nThis example can serve to create a set of standard tasks for work items of a certain type. Say:\r\n Analyze issue\r\n Fix issue\r\n Test issue\r\n\r\n`\r\n!-- WorkItems --\r\n<rule name=\"NewTask\"\r\n      appliesTo=\"Bug\"\r\n    <![CDATA[\r\n    var parent = self;\r\n    if (!self.HasChildren())\r\n    {\r\n        // use self to pass in the Team Project Context\r\n        var child = store.MakeNewWorkItem(self, \"Task\");\r\n        child[\"Title\"] = \"Task auto-generated for \" + parent[\"Title\"];\r\n  \r\n        // use the name of the relationship or one of the pre-defined static values\r\n        // by adding the link to the child, you don't change the parent in this script.\r\n        child.AddWorkItemLink(parent, \"parent\");\r\n        // child.AddWorkItemLink(parent, WorkItemImplementationBase.ParentRelationship); //should also work\r\n    }\r\n    ]]\r\n/rule\r\n`\r\n\r\nSee also:\r\n https://github.com/tfsaggregator/tfsaggregator/blob/master/UnitTests.Core/ConfigurationsForTests/NewObjects.policies",
        "tags": []
    },
    {
        "uri": "/content/using/examples/auto-open-auto-close",
        "title": "Auto-Open and Auto-Close",
        "content": "\r\nExample: Auto-open, Auto Close\r\nProcess template: Scrum\r\n\r\n`\r\nrule name=\"AutoOpen\" appliesTo=\"Task\"\r\n\t!-- Update Work Item to Committed if a task became \"active\" --\r\n\t<![CDATA[\r\n\tif (new[] {\"In Progress\", \"To Do\"}.Contains((string)self[\"System.State\"]))\r\n\t{\r\n\t\tif(self.HasParent() && ((string)self.Parent[\"System.State\"]) != \"Committed\")\r\n\t\t{\r\n\t\t\tself.Parent.TransitionToState(\"Committed\", \"Auto Activated\");\r\n\t\t}\r\n\t}\r\n\t]]\r\n/rule\r\n\r\nrule name=\"AutoClose\" appliesTo=\"Task\"\r\n\t!-- Update Work Item to Done if a all child tasks are Done or Removed --\r\n\t<![CDATA[\r\n\tif ((string)self[\"System.State\"] == \"Done\" && self.HasParent() && ((string)self.Parent[\"System.State\"]) != \"Done\")\r\n\t{\r\n\t\tif (self.Parent.Children.All(child = new[] {\"Removed\", \"Done\"}.Contains((string)child[\"System.State\"])))\r\n\t\t{\r\n\t\t\tself.Parent.TransitionToState(\"Done\", \"Auto done\");\r\n\t\t}\r\n\t}\r\n\t]]\r\n/rule\r\n`",
        "tags": []
    },
    {
        "uri": "/content/using/History-Field",
        "title": "History field",
        "content": "\r\nHistory field\r\n\r\nThe History field always appends a new message, the property allows to edit the message until work item is saved.\r\n\r\nFor example, this code causes an infinite loop (eventually stopped by rateLimiting feature).\r\n`\r\nself.History = \"Hello\";\r\n`\r\nAggregator is triggered again and again for the same work item.\r\n\r\n Some background information\r\n\r\nThe TFS aggregator only updates a work item if any field has changed by its calculations. If the calculations yield the same value as last time, the work item is considered clean and no new revision is created.\r\n\r\nThe History field is a strange kind of field, it always being empty, unless you've added a new value to it while processing. Therefore, setting the history field to anything other than string.Empty or null will cause a workitem to be saved.\r\n\r\nWhenever a workitem is saved, the TFS Aggregator triggers again. This is by design and allows for cascading rules. It's also why we've recently added a rate limiter. Normally the same set of rules triggers again, all calculations yield the same value and that breaks the loop that would otherwise be created.\r\n\r\nExcept when a rule always sets the value of the history field. As it was empty when we started calculating and is now not empty it will cause the work item to be saved.\r\n\r\nTo prevent this from happening there are a few things you can do:\r\n\r\n Before setting the History field, check the .IsDirty property of the work item. If it's not dirty, don't add anything to the history.\r\n Iterate through the revisions of the work item to ensure that you're not adding the same comment you added last time. This causes additional database and network traffic, and is therefore less desirable.\r\n Don't store your data in the History Field, instead stick it in a custom field or use any of the pre-existing fields to store your data in. (Don't append to an existing field as that would cause the same behavior)\r\n If you're not using Impersonation, check whether the \"Changed By\" field is set to the service account and assume that the changes are not made by a human, therefore skipping the changes to the history field.\r\n\r\nMarker Technique\r\n\r\nThis technique corresponds to suggestion 2, i.e. using a Marker to distinguish between user and rule changes.\r\n\r\n`\r\nconst string HistoryMarker = \"===\";\r\n\r\nvar lastRevision = self.LastRevision;\r\nvar history = lastRevision.Fields[\"History\"];\r\nstring lastValue = (string) history.Value;\r\n\r\nlogger.Log(\"At revision {0} History value is '{1}'\", lastRevision.Index, lastValue);\r\n\r\nif (!lastValue.StartsWith(HistoryMarker))\r\n{\r\n  self.History = HistoryMarker + \"Hello\";\r\n  logger.Log(\"Marker added\");\r\n}\r\n`\r\n",
        "tags": []
    },
    {
        "uri": "/content/using/index",
        "title": "Users' Guide",
        "content": "\r\nUsers' Guide to TFS Aggregator\r\n\r\nThis Guide explains how to write the Rules.",
        "tags": []
    },
    {
        "uri": "/content/using/object-model",
        "title": "Objects Reference",
        "content": "\r\nAggregator exposes some predefined objects or variables to your rules:\r\n\r\n self as the pivot for all computation.\r\n store to access the entire set of work items.\r\n logger to add a trace message to the log output.\r\n Library access to a library of pre-canned functions.\r\n\r\nWe will refer the TeamCollection containing the self work item as the current Collection. \r\n",
        "tags": []
    },
    {
        "uri": "/content/using/objects-reference/library-objects",
        "title": "Library Objects",
        "content": "\r\nLibrary of utility functions. (v2.2)\r\nIt exposes two static methods SendMail and GetEmailAddress.\r\n\r\nGetEmailAddress\r\nRetrieve the email address for a user.\r\n\r\nYou can use the DOMAIN\\user form,\r\n`\r\nstring email = Library.GetEmailAddress(\"WIN-3H7CMUV7KDM\\\\User1\", \"does-not-exists@example.com\");\r\n`\r\n\r\nor the User Display name.\r\n`\r\nstring email = Library.GetEmailAddress(\"User One\", \"does-not-exists@example.com\");\r\n`\r\n\r\n SendMail\r\nSend an email using TFS current configuration.\r\n\r\n`\r\nstring to = \"test@example.com\";\r\nstring subject = \"Sent from a Rule\";\r\nstring body = \"It worked!\";\r\nLibrary.SendMail(to, subject, body);\r\n`\r\n\r\nThe From address is configured in TFS and cannot be changed.\r\n",
        "tags": []
    },
    {
        "uri": "/content/using/objects-reference/logger-object",
        "title": "logger Object",
        "content": "\r\nAllows to add a trace message to the log output via the Log method.\r\nIt works like Console.WriteLine, accepting a format string followed by optional arguments.\r\nIf you do not specify the importance, the message will be logged at Verbose level.\r\n\r\nExamples\r\n\r\n`\r\nlogger.Log(\"Hello, World from {1} {0}!\", self.Id, self.TypeName);\r\n\r\nlogger.Log(LogLevel.Warning, \"Unexpected work item state!\");\r\n`\r\n\r\nPossible values are:\r\n Critical\r\n Error\r\n Warning\r\n Information\r\n Verbose\r\n Diagnostic\r\n\r\nEach message goes to\r\nDebug output (visible using DebugView)\r\nWindows Application EventLog using TFS Aggregator source, when level is at Warning or Critical level\r\n.Net Trace listeners\r\n\r\nThe .Net Trace Source for user messages is TfsAggregator.User; TFS Aggregator own messages have TfsAggregator.ServerPlugin Trace Source.\r\n",
        "tags": []
    },
    {
        "uri": "/content/using/objects-reference/self-object",
        "title": "self Object",
        "content": "Represents the work item that triggered the rule and corresponds to the IWorkItemExposed interface.\r\n\r\nFields collection\r\n\r\nYou can access the Fields collection using either syntax:\r\n`\r\nself.Fields[\"field_name\"]\r\n`\r\nPrefer using Reference names e.g. System.Title as they do not depend on localization and are more resilient to Process template changes.\r\n\r\nTo simply access a field value, you can use self[\"fieldname\"] as a shorthand for self.Fields[\"fieldname\"].Value\r\n\r\nFor numeric and dates you may prefer using\r\n`\r\nvar num = self.GetFieldint(\"field_name\", 42);\r\n`\r\nfor other type of fields we suggest to use the following syntax\r\n`\r\nvar str = self[\"field_name\"]?.ToString();\r\n`\r\n\r\nThe Aggregator Field exposes the following properties:\r\n Name\r\n ReferenceName\r\n Value\r\n Status\r\n OriginalValue\r\n DataType\r\n\r\n\r\n\r\n Parent property\r\nHelper property to navigate a work item's parent in the Parent-Child hierarchy. Applies to any work item object.\r\n\r\n`\r\nself.Parent[\"System.Title\"]\r\n`\r\n\r\nChildren property\r\nHelper property to navigate a work item's children in the Parent-Child hierarchy.\r\n\r\n`\r\nforeach (var child in self.Children)\r\n{\r\n   if (child.TypeName == \"Bug\")\r\n   {\r\n      //...\r\n   }\r\n}\r\n`\r\n\r\n HasParent / HasChildren / HasRelation methods\r\nHelper methods to avoid referencing null properties. Applies to any work item object.\r\n`\r\nif (self.HasParent()) {\r\n   self.Parent[\"System.Title\"] = \"*** \" + self.Parent[\"System.Title\"];\r\n}\r\n`\r\nAlways prefer the Immutable name of the Link Type, e.g. System.LinkTypes.Hierarchy-Reverse instead of Parent in \r\nHasRelation.\r\nYou can use the pre-defined WorkItemImplementationBase.ChildRelationship and WorkItemImplementationBase.ParentRelationship.\r\n\r\nAddWorkItemLink methods\r\nAdd a link to another work item.\r\n`\r\nvar parent = self;\r\nif (!self.HasChildren())\r\n{\r\n    var child = store.MakeNewWorkItem((string)parent[\"System.TeamProject\"], \"Task\");\r\n    child[\"Title\"] = \"Task auto-generated for \" + parent[\"Title\"];\r\n    child.AddWorkItemLink(parent, WorkItemImplementationBase.ParentRelationship);\r\n}\r\n`\r\nYou can use the pre-defined WorkItemImplementationBase.ChildRelationship and WorkItemImplementationBase.ParentRelationship.\r\n\r\n Be careful to use the Immutable name of a Link Type, e.g. System.LinkTypes.Hierarchy-Reverse.\r\n\r\n AddHyperlink method\r\nAdd an hyperlink to an URL.\r\n`\r\nself.AddHyperlink(\"https://github.com/tfsaggregator/tfsaggregator\", \"Automatically added\");\r\n`\r\n\r\nHistory and related properties\r\nself offers the History RevisedDate and Revision properties.\r\n\r\nIn addition, the LastRevision property offers access to latest Fields values. While PreviousRevision and NextRevision can be used to traverse the history of the workitem.\r\n\r\n Miscellaneous properties\r\n\r\nThe IsValid method is important to check is you set some invalid field value on a work item.\r\n\r\nYou can get the Id and TypeName of a work item\r\n\r\n<!--\r\n    // state helpers; must be on interface to work on WorkItemLazyReference\r\n    void TransitionToState(string state, string comment);\r\n--\r\n\r\n\r\nFluent Queries\r\n\r\nYou can get work items related using the utility methods to build a query. Applies to any work item object.\r\n\r\n WhereTypeIs filters on work item type\r\n AtMost depth of search, i.e. maximum number of links to follow\r\n FollowingLinks filters on link type\r\n\r\nIt is particularly useful for traversing many links.\r\n\r\n Example\r\n\r\n`\r\nvar tests = self.FollowingLinks(\"Microsoft.VSTS.Common.TestedBy-Forward\").WhereTypeIs(\"Test Case\");\r\nforeach (var test in tests)\r\n{\r\n   if (test[\"Microsoft.VSTS.Common.Severity\"] == \"1 - Critical\") {\r\n      // do something\r\n   }\r\n}\r\n`\r\n\r\nLinq\r\n\r\nYou can use Linq queries on these collections:\r\n Children\r\n Fields\r\n\r\n Examples\r\n\r\nRoll-up code\r\n`\r\nvar totalEffort = self.Parent.Children.Where(child = child.TypeName == \"Task\").Sum(child = child.GetField(\"TaskEffort\", 0));\r\n`\r\n\r\nSum children's estimate\r\n`\r\nforeach (var child in self.Children.Where(child = child.Field.Any(field = field.ReferenceName == \"Microsoft.VSTS.Scheduling.OriginalEstimate\")))\r\n{\r\n   if (child.TypeName != \"autogenerated\")\r\n   {\r\n      checkedValue += child.GetFielddouble(\"Microsoft.VSTS.Scheduling.OriginalEstimate\", 0.0);\r\n      othersCount += 1;\r\n   }\r\n   else\r\n   {\r\n      autogeneratedCount += 1;\r\n   }\r\n}\r\n`\r\n",
        "tags": []
    },
    {
        "uri": "/content/using/objects-reference/store-object",
        "title": "store Object",
        "content": "\r\nRepresents the current Collection's Work Items and corresponds to the IWorkItemRepositoryExposed interface.\r\nIt exposes only two methods GetWorkItem and MakeNewWorkItem.\r\n\r\nGetWorkItem method\r\n\r\nRetrieves a work item from the current Collection by ID.\r\n\r\n`\r\nvar myWorkitem = store.GetWorkItem(42);\r\n`\r\n\r\n MakeNewWorkItem methods\r\nAdd a new WorkItem to current Collection.\r\n\r\n`\r\nvar newWorkItem = store.MakeNewWorkItem(self, \"Bug\");\r\n`\r\n\r\nThis syntax will create the new work item in the same TeamProject as self.  \r\n\r\n`\r\nvar newWorkItem = store.MakeNewWorkItem(\"MyProject\", \"Bug\");\r\n`\r\n\r\nUsing this overload, you can specify the TeamProject.\r\n\r\nBoth methods require specifying the new work item's type.\r\n\r\nThe new work item Fields have default values; it is not committed to the database until all the rules have fired and Aggregator returns control to TFS.\r\n\r\n<!--\r\nGetGlobalList method\r\nRetrieves the collection of items for the named Global List.\r\n\r\n`\r\nvar items = store.GetGlobalList(\"Aggregator - UserParameters\");\r\n`\r\n\r\n The global list name must be unique per-collection.\r\n--\r\n",
        "tags": []
    },
    {
        "uri": "/content/using/policy-examples",
        "title": "Examples of Policies",
        "content": "\r\nSample polices\r\n\r\nThe Unit tests use policy files from UnitTests.Core\\ConfigurationsForTests folder, this are the most correct and tested. They do not show how to solve real world \r\n\r\nThe samples\\TFSAggregator2.ServerPlugin.policies should be your starting point. This file contains a no-harm policy: it simply logs an \"Hello, World\" message when invoked. The comments remind the syntax. \r\n\r\nFrom time to time, we test the policies contained in the ManualTests folder. They are good to learn but should not be trusted 100%, at least until we are able to setup automated integration testing.\r\n\r\n\r\n Example Aggregations\r\n\r\nCalculated field\r\n\r\n`\r\nrule name=\"Sum\" appliesTo=\"Task\" hasFields=\"Title,Description\"<![CDATA[\r\n    self[\"Estimated Work\"] = (double)self[\"Estimated Dev Work\"] + (double)self[\"Estimated Test Work\"];\r\n]]/rule\r\n`\r\n\r\nThis aggregation will total the values found in the Estimated Dev Work and Estimated Test Work fields for any Task work item.\r\nThe total will be placed in the Estimated Work field on the same work item as the source values were found.\r\n\r\n\r\n\r\n Rollup field on parent\r\n\r\n`\r\nrule name=\"Rollup\" hasFields=\"Estimated Dev Work;Estimated Test Work\"<![CDATA[\r\n  if (self.HasParent()) {\r\n    self.Parent[\"Total Estimate\"] = (double)self.Parent[\"Estimated Dev Work\"] + (double)self[\"Estimated Test Work\"];\r\n  }\r\n]]/rule\r\n`\r\n\r\nThis aggregation will total the values found in the Estimated Dev Work and Estimated Test Work fields for all Task work items on the parent.\r\nThe total will go in the Total Estimate field on the parent one level up from the Task (i.e. the direct parent).\r\nIn the Microsoft Visual Studio Scrum template that is always a Bug or Product Backlog Item. \r\n\r\n Note on States: TFS has controls setup on State Transitions.\r\n Most templates do not allow you to go directly from a New state to a Done state.\r\n\r\n\r\n\r\nPick children satisfying condition\r\n\r\n`\r\nvar child in self.Children.Where(\r\n   child = child.Field.Any(\r\n      field = field.ReferenceName == \"Custom.Product\")\r\n);\r\n`\r\n\r\n\r\n Using Linq to Aggregate\r\n\r\n`\r\nrule name=\"RollupTask\" appliesTo=\"Task\"<![CDATA[\r\nif (self.HasParent())\r\n{\r\n    var parent = self.Parent;\r\n    parent[\"Microsoft.VSTS.Scheduling.CompletedWork\"] = parent.Children.Sum(task = task.GetFielddouble(\"Microsoft.VSTS.Scheduling.CompletedWork\", 0d));\r\n    parent[\"Microsoft.VSTS.Scheduling.RemainingWork\"] = parent.Children.Sum(task = task.GetFielddouble(\"Microsoft.VSTS.Scheduling.RemainingWork\", 0d));\r\n    parent[\"Microsoft.VSTS.Scheduling.OriginalEstimate\"] = parent.Children.Sum(task = task.GetFielddouble(\"Microsoft.VSTS.Scheduling.OriginalEstimate\", 0d));\r\n}\r\n]]/rule\r\n`\r\n\r\nThis rule updates a Product Backlog Item or Bug whenever any child Task is added or changes. The Completed Work, Remaining Work and Original Estimate on the parent become the sum of the corresponding fields of children Tasks.\r\nNote that children Bug or Test Case do not update the parent.\r\n",
        "tags": []
    },
    {
        "uri": "/content/using/policy-syntax",
        "title": "Configuration XML syntax",
        "content": "\r\nReference to XML syntax of Policies file.\r\n\r\n`\r\n?xml version=\"1.0\" encoding=\"utf-8\"?\r\n`\r\n\r\nThis is the basic beginning to an XML file. Do not change it.\r\n\r\n`\r\nAggregatorConfiguration\r\n`\r\n\r\nAggregatorConfiguration: The main node for all the configuration options. (Single)\r\n\r\n`\r\n    runtime debug=\"False\"\r\n`\r\n\r\nruntime: Configure generic behavior. (Once, Optional)\r\n\r\n debug: turns on debugging options (Optional, default: False)\r\n\r\n`\r\n        rateLimiting interval=\"00:00:10.00\" changes=\"10\" /\r\n`\r\nrateLimiting: Define how Aggregator rejects incoming requests. (Once, Optional)\r\n\r\n interval: Timespan to validate. (Optional, default: 00:00:01.00) \r\n changes: Maximum number of changes in interval. (Optional, default: 5 )\r\n\r\nUse RateLimiting.policy to test your configuration on a server. \r\n\r\n`\r\n        logging level=\"Diagnostic\"/\r\n`\r\n\r\nlogging: Define logging behavior. (Once, Optional)\r\n\r\n level: The level of logging. (Optional)\r\nValid values are:\r\n     Critical\r\n     Error\r\n     Warning\r\n     Information or Normal -- default value\r\n     Verbose\r\n     Diagnostic.\r\nSee the Help page for more information: TFS Aggregator Troubleshooting\r\n\r\n`\r\n        script language=\"C\" /\r\n`\r\n\r\nscript: Define script engine behavior. (Once, Optional)\r\n\r\n language: The language used to express the rules. (Optional)\r\nValid values are:\r\n    CS,CSHARP,C# -- default value\r\n    VB,VB.NET,VBNET\r\n    PS,POWERSHELL -- Experimental!\r\n\r\n`\r\n        server baseUrl=\"http://localhost:8080/tfs\" /\r\n`\r\n\r\nserver: Define server configuration. (2.1, Once, Optional)\r\n\r\n baseUrl: Forces the URL that Aggregator use to access TFS. (Optional)\r\n Can be useful is TFS is misconfigured, or you have some special requirements.\r\n Avoid to use if possibile.\r\n\r\n\r\n`\r\n        authentication autoImpersonate=\"true\" /\r\n        authentication personalToken=\"abcd1234654sdfsfsdfs45645654645\" /\r\n        authentication username=\"user1\" password=\"password1\" /\r\n`\r\n\r\nauthentication: Define authentication behavior. (Once, Optional)\r\n\r\n autoImpersonate: false (default) the TFS Service account, true the user requesting. (Optional)\r\n personalToken: A Personal Access Token. (WebHooks, Optional)\r\n username: A Username. (WebHooks, Optional)\r\n password: A Password in clear text. (WebHooks, Optional)\r\n\r\n`\r\n    snippet name=\"MySnippet\"\r\n    /snippet\r\n`\r\n\r\nsnippet: Represents a code macro rule. (2.2, Repeatable)\r\n\r\n name: The name of this code macro. (Mandatory)\r\n\r\n\r\n`\r\n    function\r\n    /function\r\n`\r\n\r\nfunction: Contains methods callable from rules. (2.2, Repeatable)\r\n\r\n\r\n`\r\n    rule name=\"Noop\" appliesTo=\"Task,Bug\" hasFields=\"System.Title,System.Description\"\r\n    /rule\r\n`\r\n\r\nrule: Represents a single rule. (Repeatable)\r\n\r\n name: The name of this rule. (Mandatory)\r\n appliesTo: The name of the work item type that this rule will target. (All: *, List, Optional, List separators: ,;)\r\n hasFields: The work item must have the listed fields for the rule to apply. (All: *, List, Optional, List separators: ,;)\r\n changes: New,Change,Delete,Restore (default) what change event triggers the Rule. (WebHooks, Optional)\r\n _content_: the script to execute when the rule triggers. (Mandatory)\r\n   The self ($self in PowerShell) variable contains the work item that triggered the plugin.\r\n   The self ($self in PowerShell) variable contains the work item that triggered the plugin.\r\n\r\nWe recommended using CDATA to wrap script code.\r\nSee Scripting for additional details on Rules' code.\r\n\r\n`\r\n    policy name=\"DefaultPolicy\"\r\n`\r\n\r\npolicy: Represent a set of aggregation rules that apply to a particular scope. (Repeatable)\r\n\r\n name: The name of this policy. (Mandatory)\r\n\r\nAll scopes must match for the policy to apply (logical and).\r\n\r\n`\r\n        collectionScope collections=\"DefaultCollection\" /\r\n`\r\n\r\ncollectionScope: Scope the policy to a list of collections. (Optional)\r\n\r\n collections: The TFS Collection to which the policy applies. (All: *, List, Mandatory, List separators: ,;)\r\n\r\n`\r\n        templateScope name=\"Scrum\" /\r\n`\r\n\r\ntemplateScope: Scope the policy to Team Projects using a particular Process Template. (Optional, Repeatable)\r\n\r\n name: Name of Process Template matching. (Mandatory, mutually exclusive with typeid)\r\n\r\ntemplateScope requires that name must be present.\r\n\r\n`\r\n        projectScope projects=\"Project1,Project2\" /\r\n`\r\n\r\nprojectScope: Scope the policy to listed Team Projects. (Optional)\r\n\r\n projects: List of Team Project names. (All: *, List, Mandatory, List separators: ,;)\r\n\r\n`\r\n        ruleRef name=\"Noop\" /\r\n`\r\n\r\nruleRef: Reference to a previously declared rule. (Repeatable)\r\n\r\n name: Name of existing Rule. (Required)\r\n\r\nRules apply in order.\r\n",
        "tags": []
    },
    {
        "uri": "/content/using/scripting-pitfalls",
        "title": "Common Pitfalls",
        "content": "\r\nNull\r\n\r\nAny field can return null. Casting null to a numeric value or a date throws a NullReferenceException.\r\nThe following C code\r\n`\r\n(double)self.Parent[\"Microsoft.VSTS.Scheduling.OriginalEstimate\"]\r\n`\r\nmay succeed or throw.\r\n\r\nThere are many ways to overcame this issue: the null-coalescing operator, use the GetField helper function or check the Valid property.\r\nSee Tricks&Tips for examples.\r\n\r\nHistory\r\n\r\nThe History and Revision properties are tricky.\r\n\r\nImagine this sequence:\r\n A user opens a work item, whose Revision property values 7\r\n She edits the Description field and saves\r\n TFS save the changes to the database and increments Revision to 8\r\n Aggregator is notified of the change\r\n\r\nAt this point self.Revision is 8 and LastRevision.Index is 7. Throught LastRevision one can see that self.LastRevision.Fields[\"Description\"].Value equals what is saved in the database, while OriginalValue is the value before user edit.\r\n\r\nIf the Rule changes any field, you have this:\r\n Aggregator run a rule that changes a field\r\n Aggregator notices the edit and save the workitem to the database\r\n TFS triggers Aggregator again (maybe on a different machine), this time Revision property is 9\r\n \r\nSee History field for full presentation.\r\n",
        "tags": []
    },
    {
        "uri": "/content/using/scripting-tricks-n-tips",
        "title": "Tricks & Tips",
        "content": "\r\nThe examples are in C#\r\n\r\nUse Fields' Reference Names\r\n\r\nWrite your rules using the Reference name for fields, e.g. Microsoft.VSTS.Common.Priority.\r\nThat way your rules will work on process templates in different languages: Priority becomes Priorität in a German template.\r\n\r\nAlso the name may change in different template or newer version of the same template. Your rules are more likely to survive TFS upgrades unharmed.\r\n\r\n Use Link Types' Reference Names\r\n\r\nWrite your rules using the Reference name for link types, e.g. Microsoft.VSTS.Common.TestedBy-Forward.\r\n\r\nField can be null\r\n\r\nRemember that a work item field value is of type object and can be null.\r\n\r\nStyle 1: use the null-coalescing operator\r\n`\r\n(double)(self.Parent[\"Microsoft.VSTS.Scheduling.OriginalEstimate\"] ?? 0d)\r\n`\r\nnotice the parentheses and the cast.\r\n\r\nStyle #2: use the GetField helper function\r\n`\r\nself.Parent.GetFielddouble(\"Microsoft.VSTS.Scheduling.OriginalEstimate\", 0d)\r\n`\r\ninternally uses a try..catch block.\r\n\r\nStyle #3: check the Valid property\r\n\r\n`\r\nvar parentField = self.Parent[\"Microsoft.VSTS.Scheduling.OriginalEstimate\"];\r\nif (parentField.Status == FieldStatus.Valid) {\r\n  parentField.Value += (double)self[\"Microsoft.VSTS.Scheduling.OriginalEstimate\"];\r\n}\r\n`\r\nnotice that parent field is left untouched is it has no value.\r\n\r\n\r\n\r\nTrace your steps\r\n\r\nConsider using the logger object in non-trivial rules or when you are uncertain of the values in use.\r\n\r\n`\r\nif (self.HasParent())\r\n{\r\n    var parent = self.Parent;\r\n    logger.Log(\"Task {0} updates {1} #{2}\", self.Id, parent.TypeName, parent.Id);\r\n    \r\n    parent[\"Microsoft.VSTS.Scheduling.CompletedWork\"] = parent.Children.Sum(task = task.GetFielddouble(\"Microsoft.VSTS.Scheduling.CompletedWork\", 0d));\r\n    parent[\"Microsoft.VSTS.Scheduling.RemainingWork\"] = parent.Children.Sum(task = task.GetFielddouble(\"Microsoft.VSTS.Scheduling.RemainingWork\", 0d));\r\n    \r\n    logger.Log(\"CompletedWork is {0}, RemainingWork is {1}\", parent[\"Microsoft.VSTS.Scheduling.CompletedWork\"], parent[\"Microsoft.VSTS.Scheduling.RemainingWork\"]);\r\n}\r\n`\r\n\r\nThe output is sent to debugger output and .Net Trace. \r\n\r\nYou can use DebugView from Microsoft's SysInternals site at http://technet.microsoft.com/en-us/sysinternals/bb896647.\r\n\r\nDebugView is a lightweight Trace Listener and will capture the trace messages from TFSAggregator.\r\n\r\n\r\nWe would recommend adding the TFSAggregator: filter to DebugView so that you only see the TFSAggregator traces.\r\n\r\n\r\nMake sure to enable the Capture Global Win32 option.\r\n\r\n You have to run DebugView on _all_ TFS Application Tier machines.\r\n\r\n\r\n\r\nInfinite cycle\r\n\r\nAlways set a Rate Limit feature to limit the damage of infinite loops.\r\n\r\n`\r\nAggregatorConfiguration\r\n    runtime\r\n        rateLimiting interval=\"00:00:01.00\" changes=\"5\" /\r\n`\r\n\r\n\r\n Use Template Scope\r\n\r\nInstead of scoping Rules to a Collection or a set of Projects, you can define to apply the Rules to any Project using a specific template. E.g.\r\n`\r\ntemplateScope name=\"Scrum\" /\r\n`\r\nRemember that name must match exactly.\r\nVerify before each TFS upgrade if any Process Template has changed name and update your policies eventually. \r\n\r\n\r\nUse hasFields instead of appliesTo\r\n\r\nThe appliesTo filter restrict a Rule to a specific set of work item types.\r\nYou can define a more generic rule using the hasFields filter. Using it the code does not depends on specific work item type and the way they are named.\r\n\r\nThis has the advantage that the rule will also work when people customize the template by copying an existing Work Item Type, like Task - In Sprint Bug. \r\n\r\n\r\n\r\n Numeric Deltas\r\n\r\nThe Problem\r\n\r\nConsider the following rule\r\n`\r\nself.Parent[\"Custom.RemainingWork\"] = (double)self.Parent[\"Custom.RemainingWork\"] + (double)self[\"Microsoft.VSTS.Scheduling.RemainingWork\"];\r\n`\r\nThe problem is that the parent value will be increased with every change.\r\n\r\nIf the child has a value of 5, the parent value will be increased by 5. When I change the child value from 5 to 2, the parent value will be increased be 2, but it should be decreased with 3.\r\n\r\nThe requirement is to aggregate the difference from the new value to the old value and not the raw new value only.\r\n\r\n A Solution\r\n\r\nA simple way is adding an hidden field, say Custom.PreviousRemainingWork. The rule will become something like\r\n\r\n`\r\ndouble delta = (double)(self[\"Custom.PreviousRemainingWork\"]??0d) - (double)(self[\"Microsoft.VSTS.Scheduling.RemainingWork\"]??0d);\r\nself.Parent[\"Custom.RemainingWork\"] = (double)(self.Parent[\"Custom.RemainingWork\"]??0d) + delta;\r\nself[\"Custom.PreviousRemainingWork\"] = (double)(self[\"Microsoft.VSTS.Scheduling.RemainingWork\"]??0d);\r\n`\r\n",
        "tags": []
    },
    {
        "uri": "/content/using/scripting",
        "title": "Scripting the Rules",
        "content": "\r\nScript languages\r\n\r\nYou can use C and VB.Net to write your rules. Powershell also works but we had little tested it.\r\n\r\nC and VB\r\nYou can use only types from these assemblies:\r\n System\r\n System.Core\r\n Microsoft.TeamFoundation.WorkItemTracking.Client\r\n Aggregator.Core\r\nAny other reference will result in compile errors.\r\n\r\nThe following namespaces are imported (C# using, VB Imports):\r\n Microsoft.TeamFoundation.WorkItemTracking.Client\r\n System.Linq\r\n Microsoft.TeamFoundation.WorkItemTracking.Client.CoreFieldReferenceNames\r\n Aggregator.Core and descendants\r\n\r\nCode\r\n\r\nYou can make your code more modular, using macro snippets or functions.\r\n\r\n`\r\nsnippet name=\"MySnippet\"<![CDATA[\r\n    logger.Log(\"You entered MySnippet snippet.\");\r\n]]/snippet\r\n\r\nfunction<![CDATA[\r\n  int MyFunc() { return 42; }\r\n]]/function\r\n\r\nrule name=\"MyFirstRule\" appliesTo=\"Task\" hasFields=\"Title\"<![CDATA[\r\n    ${MySnippet}\r\n    logger.Log(\"Hello, World from {1} {0}!\", self.Id, self.TypeName);\r\n    logger.Log(\"MyFunc returns {0}.\", MyFunc());\r\n]]/rule\r\n`\r\n\r\nThis way you can reuse the same code in multiple rules.\r\n",
        "tags": []
    },
    {
        "uri": "/content/using/upgrade-from-v1",
        "title": "Upgrading from v1",
        "content": "\r\nMigrating from v1\r\nTFS Aggregator 2 is a full rewrite of the plugin. The old rule syntax is no longer supported. In case you're looking for the latest version of version 1.01, you can still find it here (including a large number of fixes and security updates).\r\n\r\nIf you want to upgrade to 2.x you'll have to rewrite your rules in the new format, the installation and upgrade process are explained below.\r\n\r\nNote: we won't provide any further support on this old version. But if you have a large investment in the old-style rules, it may provide you a better, stabler version until you're ready to move to V2. \r\n\r\nNote: You can run both V1 and V2 side-by-side on the same TFS system, you will have to be extra careful not to create infinite loops though.\r\n\r\n Upgrade binaries\r\n\r\nRemove old version, namely delete the TFSAggregator.dll and AggregatorItems.xml files from the plugin location on the Application Tier of your TFS Server.\r\n\r\nThe plugin folder is usually at this path: C:\\Program Files\\Microsoft Team Foundation Server 12.0\\Application Tier\\Web Services\\bin\\Plugins\r\n\r\nAt this point deploy the new version as described in Install.\r\n\r\n\r\n\r\nConvert the rules\r\n\r\nPlease refer old syntax page and new syntax.\r\n\r\n Sample conversion\r\n\r\nThe old aggregation adds up the estimated work on the task.\r\n\r\n`\r\nAggregatorItem operationType=\"Numeric\" operation=\"Sum\" linkType=\"Self\" workItemType=\"Task\"\r\n    TargetItem name=\"Estimated Work\"/\r\n    SourceItem name=\"Estimated Dev Work\"/\r\n    SourceItem name=\"Estimated Test Work\"/\r\n/AggregatorItem\r\n`\r\n\r\nThe equivalent rule in the policy is\r\n\r\n`\r\nrule name=\"Sum\" appliesTo=\"Task\" hasFields=\"Title,Description\"<![CDATA[\r\n    self[\"Estimated Work\"] = (double)self[\"Estimated Dev Work\"] + (double)self[\"Estimated Test Work\"];\r\n]]/rule\r\n`\r\n\r\nNote the cast on fields' values.\r\n",
        "tags": []
    },
    {
        "uri": "/content/using/writing-rules",
        "title": "Writing Rules and Policies",
        "content": "The samples\\TFSAggregator2.ServerPlugin.policies should be your starting point. This file contains a no-harm policy: it simply logs an \"Hello, World\" message when invoked. The comments remind the syntax. \r\n\r\nEditing a policy\r\n\r\nThe XML Schema definition is in file Aggregator.Core\\Configuration\\AggregatorConfiguration.xsd. This is the ultimate truth: policy file is checked against XSD before being used.\r\n\r\nIt can also help you editing the policy file in Visual Studio.\r\nOpen TfsAggregator2 solution in Visual Studio, open a policy file using built-in Xml editor, Select XML from the main menu, then Schemas. In the dialog windows select Use this Schema for AggregatorConfiguration.xsd from the drop-down list.\r\n\r\n",
        "tags": []
    }
]